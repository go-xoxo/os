// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HASEL â€” Haskell + Emoji Language
// SVG Icons Ã— Unicode 18 Ã— Typst Ã— All Noto Fonts
// Generated by Squirrel OS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// NOTO FONT STACK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Primary text font: Noto Sans for UI clarity
#set text(font: ("Noto Sans", "Noto Sans Symbols", "Noto Sans Symbols 2", "Noto Color Emoji"), size: 11pt)

// Code blocks: Noto Sans Mono
#show raw: set text(font: "Noto Sans Mono", size: 10pt)

// Math: Noto Sans Math
#show math.equation: set text(font: "Noto Sans Math")

// Headings: Noto Serif for contrast
#show heading: set text(font: "Noto Serif", weight: "bold")

// Page setup
#set page(margin: 2cm)
#set par(justify: true, leading: 0.8em)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SVG-IN-UNICODE SHOW RULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Each PUA codepoint is intercepted and replaced
// with its SVG icon rendered at text height.
// Pipeline: Unicode 18 codepoint â†’ Typst show rule â†’ SVG â†’ PDF glyph

// --- World icons ---
#show "\u{1CC00}": image("../assets/icons/haskell.svg", height: 1em)    // Haskell (fallback: Î»)
#show "\u{1CC10}": image("../assets/icons/purescript.svg", height: 1em) // PureScript (fallback: â–³)
#show "\u{1CC20}": image("../assets/icons/elm.svg", height: 1em)        // Elm (fallback: ğŸŒ³)
#show "\u{1CC30}": image("../assets/icons/idris.svg", height: 1em)      // Idris (fallback: ğŸ‰)
#show "\u{1CC40}": image("../assets/icons/agda.svg", height: 1em)       // Agda (fallback: âˆ€)
#show "\u{1CC50}": image("../assets/icons/dhall.svg", height: 1em)      // Dhall (fallback: âš™)
#show "\u{1CC60}": image("../assets/icons/nix.svg", height: 1em)        // Nix (fallback: â„)
#show "\u{1CC70}": image("../assets/icons/typst.svg", height: 1em)      // Typst (fallback: ğ•‹)

// --- Feature icons ---
#show "\u{1CC01}": image("../assets/icons/monad.svg", height: 1em)      // Monad (fallback: â‰«)
#show "\u{1CC02}": image("../assets/icons/functor.svg", height: 1em)    // Functor
#show "\u{1CC06}": image("../assets/icons/pure.svg", height: 1em)       // Pure (fallback: â˜…)
#show "\u{1CC07}": image("../assets/icons/effect.svg", height: 1em)     // Effect (fallback: âš¡)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DOCUMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

= HASEL: Functional Programming United

#align(center)[
  #text(size: 24pt, font: "Noto Color Emoji")[ğŸ¿ï¸â˜‚ï¸âš¡]
]

#v(1em)

#align(center)[
  _Eight worlds. One umbrella. Emoji go._
]

#v(2em)

== What is HASEL?

HASEL imports the best ideas from every functional programming ecosystem
and unifies them under a single, emoji-friendly interface. Each "world"
represents a language with unique strengths:

#table(
  columns: 4,
  [*World*], [*Icon*], [*Best Feature*], [*Tagline*],
  [Haskell],    [Î»], [Type Classes],    [_Purity + laziness + type classes_],
  [PureScript], [â–³], [Row Types],       [_Strict Haskell for the browser_],
  [Elm],        [ğŸŒ³], [No Exceptions],   [_FP for everyone_],
  [Idris],      [ğŸ‰], [Dependent Types], [_Proving programs correct_],
  [Agda],       [âˆ€],  [Unicode Syntax],  [_Mathematics as code_],
  [Dhall],      [âš™ï¸], [Totality],        [_Configuration as a language_],
  [Nix],        [â„ï¸], [Reproducibility], [_The functional OS_],
  [Typst],      [ğ•‹],  [Show Rules],      [_Modern typesetting_],
)

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: HASKELL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== ğŸ§ª Haskell

_Pure functions, lazy evaluation, type classes â€” the research language that became production-ready._

=== Key Features

- *Type Classes*: Ad-hoc polymorphism via type class dispatch. Inspired Rust traits, Scala implicits, Swift protocols.
- *Lazy Evaluation*: Non-strict by default. Thunks evaluated on demand. Enables infinite structures and compositional streaming.
- *Monads*: Sequencing with context. IO, State, Reader, Writer. Key insight: monads are about COMPOSITION, not side effects.
- *GHC Extensions*: 100+ extensions from RankNTypes to TypeFamilies. GHC = compiler + research laboratory.
- *Purity*: No side effects in functions. All effects tracked in types. Equational reasoning: substitute equals for equals.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[The learning curve is real but misunderstood. The difficulty isn't monads â€” it's unlearning imperative habits.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Haskell-the-report and Haskell-via-GHC are different languages. In practice, OverloadedStrings, GADTs, TypeFamilies are mandatory.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Cabal v3 (Nix-style builds) resolved the Cabal-vs-Stack split. Use cabal for new projects.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Laziness enables beautiful abstractions but creates space leaks. BangPatterns and seq are essential in production.]

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: PURESCRIPT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== ğŸŒ PureScript

_Haskell's ideas, strict evaluation, row types â€” compiling to JavaScript and beyond._

=== Key Features

- *Row Types*: Extensible records with row polymorphism. Functions require specific fields without knowing full record shape.
- *Effect System*: Algebraic effects via the Effect monad. Each effect is a row type label. Compose effects freely.
- *JavaScript FFI*: Clean FFI to JS. Import any JS function with a type annotation. Compiler verifies PureScript-side types.
- *Strict Evaluation*: Unlike Haskell, strict by default. No space leaks from lazy thunks. Predictable performance.
- *Halogen*: Type-safe UI framework. Parent-child communication via queries and slots. More powerful than Elm for large apps.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Started as 'Haskell for JS' but evolved its own identity. Strict evaluation and row types make it distinct.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Tiny community compared to Haskell/Elm, but higher average package quality on Pursuit.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Backends for Erlang (purerl) and Go exist. The compiler architecture enables polyglot FP.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Adopted Haskell's best ideas while fixing pain points: strict by default, no String-vs-Text confusion, better records.]

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: ELM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== ğŸŒ³ Elm

_No runtime exceptions, friendly errors, The Elm Architecture â€” FP for everyone._

=== Key Features

- *The Elm Architecture*: Model-Update-View. Every app follows the same pattern. TEA inspired Redux, Vuex, SwiftUI.
- *No Runtime Exceptions*: Elm programs do not crash. The compiler catches all errors. Maybe/Result replace null/exceptions.
- *Compiler Error Messages*: The gold standard. Explains what went wrong, why, and suggests fixes. Rust and Scala 3 followed Elm's lead.
- *Semantic Versioning Enforcement*: Package manager detects API changes and enforces semver. The TOOL decides the version.
- *Managed Effects*: All effects via Cmd/Sub. No escape hatch. The runtime owns effects; your code is pure.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[The restrictions (no type classes, no FFI escape, single maintainer) are features for TEAM reliability.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[TEA changed frontend forever. Redux = TEA for React. Vuex = TEA for Vue. SwiftUI = TEA.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Maintained by one person. Coherent design but existential risk. Releases are infrequent.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[The easiest typed FP language. No monads, no type classes, no category theory. Just functions, records, unions.]

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: IDRIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== ğŸ‰ Idris

_Dependent types, totality, quantitative types â€” proving programs correct._

=== Key Features

- *Dependent Types*: Types depend on values. Vector n carries its length. The compiler PROVES bounds safety.
- *Totality Checking*: Compiler verifies functions terminate and cover all inputs. Total functions = proofs.
- *Elaborator Reflection*: Metaprogramming via compiler reflection. Write Idris that generates Idris, type-checked.
- *Quantitative Type Theory*: Idris 2 uses QTT: bindings carry quantities (0, 1, Ï‰). Enables linear types â€” use once.
- *Interactive Editing*: Type-driven dev in editor. Compiler suggests case splits, generates bodies from types.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Proved dependent types can be practical â€” general-purpose language first, proof assistant second.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Idris 2 is a rewrite in Idris 1, bootstrapped. Chez Scheme backend replaced custom C codegen.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Dependent types let you prove properties, but you PAY in code complexity. Choose what to prove carefully.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Fewer libraries than Python has web frameworks. But every program explores what types can express.]

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: AGDA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== ğŸ”¬ Agda

_Unicode syntax, cubical types, formal proofs â€” mathematics as executable code._

=== Key Features

- *Unicode Syntax*: Native Unicode identifiers: âˆ€, â†’, â‰¡, âˆ·. Mathematical notation becomes executable code.
- *Dependent Pattern Matching*: Splitting on a constructor refines types of other arguments. The compiler tracks refinement.
- *Cubical Type Theory*: Paths between types are interval functions. Univalence computes. HoTT with computation.
- *Mixfix Operators*: if\_then\_else\_ is a valid name. Underscores mark argument positions. DSLs read like prose.
- *Proof Irrelevance*: Mark proofs irrelevant with \@0. Compiler erases them at runtime. Zero-cost proofs.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Where programming meets mathematics. Used to formalize homotopy type theory and category theory.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[A proof assistant that happens to be a programming language. No web framework, no database driver.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Unicode isn't nice-to-have â€” it's how you write code. Every file looks like a math paper.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[The standard library reads like a graduate algebra textbook. Data.Nat proves its own algebraic laws.]

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: DHALL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== âš™ï¸ Dhall

_Total, typed, importable â€” configuration as a real language._

=== Key Features

- *Total Language*: Every expression terminates. No infinite loops. Config evaluation always completes.
- *Type-Safe Configuration*: Config files with real types. Import, validate, compose with full type checking.
- *Built-in Import System*: Import from URLs, files, env vars. SHA256 content-addressed for integrity.
- *Normalization*: Unique normal form per expression. Semantic equality, not textual equality.
- *Multi-Format Output*: Compile to JSON, YAML, XML. Write once, output in any format.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Proved configuration needs types. After Dhall, YAML feels like assembly.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Totality makes URL imports safe â€” code CANNOT loop forever. Only language where untrusted code is safe by design.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Technically superior to YAML, but adoption requires convincing whole teams.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Functions in config: one Dhall function generates dev, staging, prod configs. No copy-paste-modify.]

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: NIX
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== â„ï¸ Nix

_Reproducible builds, immutable packages, NixOS â€” the functional operating system._

=== Key Features

- *Reproducible Builds*: Same derivation â†’ same output, byte for byte. No 'works on my machine'.
- *Nix Store*: /nix/store with cryptographic hashes. Multiple versions coexist without conflict.
- *Flakes*: Hermetic project definitions. flake.nix declares inputs/outputs. Lock file pins everything.
- *NixOS*: Entire OS as a functional expression. Configuration is Nix. Rollback to any generation.
- *Development Shells*: nix develop = reproducible dev environment. Identical tools for every team member.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Steepest learning curve in all FP tooling. Underdocumented, cryptic errors. But nothing else compares.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Nixpkgs has 100,000+ packages. Larger than Debian, AUR, or Homebrew.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Flakes are 'experimental' after years of use. Old channels and new flakes coexist awkwardly.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Packages as values, builds as pure functions, store as cache. HASEL thinking applied to DevOps.]

#pagebreak()

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WORLD: TYPST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

== ğŸ“ Typst

_Show rules, incremental compilation, content as values â€” modern typesetting._

=== Key Features

- *Show Rules*: Intercept and transform elements. `#show "X": image("x.svg")` replaces text with SVG. Pattern matching on content.
- *Incremental Compilation*: Only recompiles what changed. Sub-second feedback for large documents.
- *Scripting Language*: Real language: variables, functions, loops. Not LaTeX macros â€” actual programming.
- *Content as Values*: Document content is first-class. Store paragraphs in variables, pass headings to functions.
- *Font Discovery*: Finds system fonts automatically. `#set text(font: "Noto Sans")` â€” all Noto variants work.

=== Insights

#block(fill: luma(245), inset: 12pt, radius: 4pt)[What LaTeX would be if designed today. Modern syntax, fast compilation, sane errors.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Show rules = pattern matching on document structure. FP thinking in typesetting.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Show rules enable mapping Unicode to SVG inline. The bridge: codepoint â†’ show rule â†’ SVG â†’ PDF.]

#block(fill: luma(245), inset: 12pt, radius: 4pt)[Pre-1.0, breaking changes happen. But pace is extraordinary and community is responsive.]

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNICODE 18 REFERENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#pagebreak()

= Appendix: Unicode 18.0 & SVG Integration

Unicode 18.0 (2025) added 11,328 characters including CJK Extension J,
the UAE Dirham sign (U+20CE), and 9 new emoji. HASEL maps its icons
to Private Use Area codepoints with standard Unicode 18 fallbacks.

== OpenType Color Table Formats

#table(
  columns: 3,
  [*Format*], [*Type*], [*Used By*],
  [COLR/CPAL], [Vector layers + palettes], [Noto Color Emoji v2, Windows],
  [SVG],       [Full SVG per glyph],       [Firefox, Adobe fonts],
  [CBDT/CBLC], [Bitmap at fixed sizes],    [Noto Color Emoji v1, Android],
  [sbix],      [Apple bitmap format],       [Apple Color Emoji],
)

== The SVG-in-Unicode Pipeline

```
Design SVG icon
  â†’ Assign PUA codepoint (U+1CC00-U+1CC7F)
  â†’ Map fallback to standard Unicode 18 symbol
  â†’ Typst show rule intercepts codepoint
  â†’ SVG rendered inline at 1em height
  â†’ PDF output with embedded vector glyph
```

== Noto Font Coverage

#table(
  columns: 3,
  [*Font*], [*Covers*], [*Use in HASEL*],
  [Noto Sans],          [Latin, Cyrillic, Greek, ...], [UI text, headings],
  [Noto Serif],         [Same scripts, serif style],   [Body text],
  [Noto Sans Mono],     [Monospaced variant],          [Code, operators],
  [Noto Sans Math],     [Mathematical symbols],        [Equations],
  [Noto Sans Symbols],  [Miscellaneous symbols],       [FP notation],
  [Noto Sans Symbols 2],[Extended symbols],             [Additional notation],
  [Noto Color Emoji],   [Full emoji set],              [World emoji, fallback],
)

== HASEL PUA Codepoint Allocation

#table(
  columns: 4,
  [*Range*], [*Count*], [*Purpose*], [*Fallback*],
  [U+1CC00], [1], [Haskell world icon], [Î» (U+03BB)],
  [U+1CC01-1CC05], [5], [Haskell feature icons], [Various math symbols],
  [U+1CC10], [1], [PureScript world icon], [â–³ (U+25B3)],
  [U+1CC11-1CC15], [5], [PureScript feature icons], [Various],
  [U+1CC20], [1], [Elm world icon], [ğŸŒ³ (U+1F333)],
  [U+1CC21-1CC25], [5], [Elm feature icons], [Various],
  [U+1CC30], [1], [Idris world icon], [ğŸ‰ (U+1F409)],
  [U+1CC31-1CC35], [5], [Idris feature icons], [Various],
  [U+1CC40], [1], [Agda world icon], [âˆ€ (U+2200)],
  [U+1CC41-1CC45], [5], [Agda feature icons], [Various],
  [U+1CC50], [1], [Dhall world icon], [âš™ (U+2699)],
  [U+1CC51-1CC55], [5], [Dhall feature icons], [Various],
  [U+1CC60], [1], [Nix world icon], [â„ (U+2744)],
  [U+1CC61-1CC65], [5], [Nix feature icons], [Various],
  [U+1CC70], [1], [Typst world icon], [ğ•‹ (U+1D54B)],
  [U+1CC71-1CC75], [5], [Typst feature icons], [Various],
  [U+1CC80-1CC83], [4], [FP operator icons], [âˆ˜ âŠ› â‰« â†¦],
)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// END
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#align(center)[#text(size: 18pt, font: "Noto Color Emoji")[ğŸ¿ï¸ğŸŒ°]]
#align(center)[_HASEL IT_]
